using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace HashTableHomework
{
    /* 목욕탕 사물함
     * 키 == 키
     * 데이터 == 사물함 내 물건
     * 접수원 == 해시함수
     * 
     * <해싱>
     * HashTable 이라는 기억공간을 할당 후 해시함수를 이용해 HashTable 내의 주소를 계산하여
     * 주어진 데이터를 해당 주소에 저장, 탐색을 수행하는 방식이다.
     * 매핑하는 과정 자체를 해싱이라고 한다.
     * 매핑 전 원래 데이터의 값을 Key, 매핑 후 데이터의 값을 Hash Value라고 한다.
     * 해싱은 속도는 빠르지만 용량을 많이 소모한다.
     * 삽입, 삭제의 빈도가 많을 때 유리하다. 
     * 키-주소 변환 방법이라고도 한다.
     *
     * <해시함수>
     * 데이터의 효율적 관리를 목적으로 임의의 길이의 데이터를 고정된 길이의 데이터로 변환시켜주는 함수이다.
     * 해시함수는 언제나 동일한 해시값을 리턴하여 테이블의 크기에 상관없이 데이터에 빠르게 접근가능
     * 암호화 정도로 생각하면 편함
     * 입력에 대한 해시함수의 결과가 항상 동일한 값이어야 함
     * [해시함수의 효율]
     * 1. 해시함수 자체가 느린 경우 의미가 없음
     * 2. 해시함수의 결과가 밀집도가 낮아야 함, 최대한 안겹치도록
     * 3. 해시테이블의 크기가 클수록 효율이 높아짐
     * 
     * Division Method, Digit Folding, Multiplication Method, Univeral Hashing, SHA-1, SHA-2, SHA-256 등
     * 여러가지 해시함수가 존재한다.
     * 일반적인 방법으로는 키와 해시값 사이에 연관성을 찾기 힘들어 보안 분야에서도 널리 사용한다.
     *
     * <해시테이블>
     * (Key, Value)로 데이터를 저장하는 자료구조 중 하나
     * 해시테이블은 각각의 Key값에 해시함수를 적용해 배열의 고유한 index를 생성하고
     * 이 index를 활용하여 값을 저장하거나 검색하게 된다.
     * 해싱을 이용하여 데이터를 저장하면 Key값으로 데이터를 찾을 때 해시함수를 1번만 수행하면 되므로
     * 매우 빠르게 데이터를 저장, 삭제, 조회할 수 있다. 
     *
     * <해시충돌>
     * 해시함수가 서로 다른 두 개의 키를 동일한 해시값으로 바꾸어 해시값이 겹치게되면 해시충돌이 발생하게 된다.
     * 모든 입력 값에 대해 고유한 해시 값을 만드는 것은 불가능하며 충돌은 피할 수 없음
     * 
     * <해시충돌 해결방안>
     * Separate Chaining(분리 연결법) : 하나의 인덱스에 들어갈 수 있는 데이터에 제한을 두지 않으므로써 충돌이 되어도 같은 인덱스 값에 자료를 넣는 방법
     * 데이터가 이미 있다면 LinkedList 처럼 노드를 추가하여 다음 노드를 가리키게 된다.
     * 자료가 많이 추가되더라도 유연하고 성능저하가 적지만 
     * 해시테이블 외에 추가적인 저장공간이 필요하여 메모리 문제를 야기하게 된다.
     * 
     * Open Addressing(개방 주소법) : 해시충돌이 발생하면 비어있는 해시테이블의 공간에 새로 추가된 데이터를 넣는 방법
     * Linear Probing) 현재 index로부터 고정된 폭만큼 이동하며 차례대로 검색해 비어 있는 곳에 데이터를 추가
     * Quadratic Probing) 폭을 제곱으로 지정하여 이동
     * Rehasing) 해시테이블이 가득 차는 경우가 발생할 경우에는 더 큰 새로운 Hash Table을 만들어 그에 맞추어 모든 데이터를 다시 해싱하는 방법
     * 개방 주소법에서는 위 방식 등을 이용하여 빈 index에 데이터를 넣게된다.
     * 해시충돌이 일어나 이동한 곳에서도 해시충돌이 발생할 수 있어 분리 연결법과 비교했을 때 추가적인 연산을 하게 된다.
     * 해싱된 값을 한 번 더 해싱하는 방식, 다른 방법들보다 많은 연산을 하게 된다.
     */


    // <해시테이블의 시간복잡도>
    // 접근			탐색			삽입			삭제
    // X			O(1)		O(1)		O(1)
    internal class HashTable
    {
    }
}
