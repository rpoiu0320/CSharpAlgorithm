namespace SortHomework
{
    internal class Program
    {
        /* 1. 선형 정렬(Linear Sorting) 3종 구현 원리 조사
         * 선형 정렬이란 : 값의 비교에 기반한 알고리즘
         * 1개의 요소를 재위치시키기 위해 전체를 확인하는 정렬
		 * n개의 요소를 재위치시키기 위해 n개를 확인하는 정렬
		 * 시간복잡도 : O(N^2)
		 * 
		 * 선형 정렬은 안쓰는 추세이지만 선형 정렬 중에서는 
		 * 인덱스 개념을 사용할 때 버블정렬을 자주 사용하는 편이다
		 * 
		 * 
         * 
         * <선택 정렬(Selection Sort)>
         * 앞에서부터 차례대로 정렬하는, N - 1 부터 1번까지의 자리에 대하여
         * 해당 자리에 넣어야 하는 원소를 선택하는 알고리즘
         * 
         * 주어진 리스트 중 최소값을 찾고 그 값을 정렬이 아직 안된 인덱스의
         * 맨 앞에 위치한 값과 교체하여 진행
         * 오름차순으로 정렬을 원할 시 최대값을 찾아 진행
         * 
         * 역순 정렬을 할 때 최적의 효율을 보여줌
         * 반면에 이미 정렬된 상태의 자료에 약간의 자료가 추가되고 재정렬 할 때는 최악의 효율을 보여줌
         * 
         * n개의 원소에 대해 n개의 메모리를 사용하기에 데이터를 하나씩 정밀 비교 가능
         * 비교 횟수는 많고 교환 횟수는 상대적으로 적다는 것이 장점이자 단점임
         * 
         * 자료가 정렬된 경우에는 불필요하게 자기 자신과 이동을 할 수도 있음
         * 
         * 기존 배열 이외에 추가적인 메모리를 거의 사용하지 않는 제자리 정렬임
         * 
         * 동작 중 배열에 동일한 값이 있으면 배열에 있는 순대로 동일한 값이 정렬되는 것을
         * 보장하지 않는 불안정 정렬임, 최소값을 구하고 교환하면서 이리저리 움직이기에
         * 
         * 시간복잡도는 모두 O(n^2)
         * 
         * 
         * 
         * <삽입 정렬(Insertion Sort)>
         * 배열의 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교하여 
         * 적절한 위치를 찾아 삽입하여 이후 인덱스들을 하나씩 밀어내어 정렬시키는 알고리즘
         * 
         * 버블정렬과 비교하였을때 상대적으로 비교횟수가 적음
         * 
         * 크기가 적은 데이터 집합을 정렬 시 버블정렬보다 탁월한 효율을 보여주며
         * 교환이 일어나지 않고 n-1의 비교만 발생함
         * 
         * 자료가 이미 정렬되어 있을 경우 
         * 각 단계에서 1번의 비교와 2번의 이동만 이루어져 최적의 효율을 보여줌
         * 반면에 입력 자료가 역순일 경우 
         * 각 단계에서 앞에 놓인 자료들을 전부 한 칸씩 뒤로 이동하여 최악의 효율을 보여주어 시간복잡도가 O(n*n) 이 될 수 있음
         * 
         * 자료의 수가 적거나 이미 정렬되어 있으면 알고리즘 자체가 매우 간단함
         * 반대로 자료의 양이 많거나 크기가 클 수록 적합하지 않음, 비교적 많은 자료들의 이동이 발생
         * 
         * 기존 배열 이외에 추가적인 메모리를 거의 사용하지 않는 제자리 정렬임
         * 
         * 동작 시 비교할 대상이 새로운 원소보다 클 때만 한자리 뒤로 이동시키므로
         * 동일한 값의 우선순위는 처음 정렬과 동일하게 유지되는 안정 정렬임
         * 
         * 시간복잡도는 모두 O(n^2)
         * 
         * 
         * 
         * <버블 정렬(Bubble Sort)>     [기술면접서 손코딩 하라고 할 가능성 있음]
         * 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 끝부터 정렬하는 방식
         * 한 사이클이 끝나면 가장 큰 원소를 마지막 자리로 정렬 후 다시 반복할 때
         * 끝자리들은 정렬이 이미 되어 있으므로 정렬된 부분들을 제외고하 반복을 하기 때문에
         * 사이클이 끝날 때마다 정렬에서 제외되는 데이터가 하나씩 늘어남
         * 
         * 선택정렬과 유사하게 n-1 부터 1번까지의 자리에 대하여 남아있는 수들 중 가장 큰 수를 각 자리로 보냄
         * 이후 남아있는 수들 중 가장 큰 수를 인접한 두 수를 비교해가며 찾음
         * 
         * 코드가 간단하여 구현이 쉬움
         * 
         * n개의 원소에 대하여 n개의 메모리를 사용, n - 1번 반복
         *  
         * 데이터를 하나씩 비교하며 첫번째부터 마지막까지 가기 때문에
         * 가장 큰 값이 첫번째에 있다면 모든 원소들과 교환이 발생함
         * 
         * 일반적으로 교환 작업이 이동 작업보다 더 복잡함
         * 
         * 정밀하게 비교가 가능하나 비교횟수가 많아 시간이 다른 정렬들에 비해 오래걸림
         * 
         * 자료가 정렬되어 있으면 최적의 효율을 보여줌
         * 반면 자료가 역순으로 정렬되어 있을 경우 최악의 효율을 보여줌
         * 
         * 
         * 기존 배열 이외에 추가적인 메모리를 거의 사용하지 않는 제자리 정렬임
         * 
         * 동일한 값의 우선순위는 처음 정렬과 동일하게 유지되는 안정 정렬임
         * 
         * 시간복잡도는 모두 O(n^2)
         * 
         * 
         *
         * 2. 3. 분할정복 정렬(Divide and Conquer Sort) 3종 구현 원리와 원리에 의한 특징
         * 분할정복이란 : 방대한 문제를 조금씩 나눠가면서 보다 쉽게 풀 수 있는 단위로 나눈 다음 다시 합쳐 해결하는 개념
         * 재귀적으로 자신을 호출하면서 연산의 단위를 조금씩 줄여가는 방식
         * 병렬적으로 문제를 해결
         * 
         * 1개의 요소를 재위치시키기 위해 전체의 1/2를 확인하는 정렬
		 * n개의 요소를 재위치시키기 위해 n/2개를 확인하는 정렬
         * 
         * 재귀적 호출을 사용하므로 오버헤드가 발생하며, 스택오버플로우나 과도하게 메모리를 사용하게되는 단점이 있음
         * 
         * 시간복잡도 : O(n*logn)
         * 
         * 
         * 
         * <힙 정렬(Heap Sort)>
         * 최대 힙 트리나 최소 힙 트리를 구성해 정렬하는 방법
         * 완전 이진 트리를 배열에 접목시킨 알고리즘
         * 우선 최대한 힙 조건에 맞게 정리한 뒤 높이가 가장 낮은 데이터를 차례대로 빼내어 정렬된 배열로 만들어줌
         * 
         * 힙 생성 방식은 삽입식, 상향식 중 아무거나 사용
         * 
         * 부가적인 메모리가 전혀 필요 없다는 게 큰 장점
         * 
         * 전체자료를 정렬하는 것이 아니라 가장 큰 값 몇 개만 필요할 때 최적의 효율을 보여줌
         * 
         * 완전 이진 트리의 전체 높이가 거의 logN임
         * 따라서 하느의 요소를 힙에 삽입하거나 삭제할 때 힙을 재정비하는 시간이 logN만큼 소요됨
         * 요소의 개수가 n개이므로 전체적으로 O(n*logn)의 시간이 걸림
         * 
         * 시간복잡도는 O(n*logn)
         *    
         *    
         * <병합정렬(Merge Sort)>
         * 하나의 배열을 두 개의 균등한 배열로 분할 후 분할된 배열을 각각 정렬한 다음
         * 이를 다시 합하여 정렬을 완성하는 알고리즘
         * 
         * 병합 작업을 수행하는 메서드는 병합 대상이 되는 배열의 두 부분을 임시배열에 복사한 후
         * 좌, 우측 절반의 시작지점을 추적함
         * 이 임시배열을 순회하며 두 배열에서 더 작은 값의 원소를 꺼내어 원래 배열에 복사해 넣음
         * 두 배열 중 한 배열에 대한 순회가 끝난 경우 다른 배열의 남은 부분을 원래 배열에 남김없이 복사해 넣고 종료됨
         * 
         * 분할하는 과정에서는 별다른 연산이 수행되지 않음
         * 따라서 비교, 이동 횟수를 살펴보면됨
         * 
         * {배열의 길이가 N= 2^k 일 때 합병 단계는 k번 발생(한 번의 합병에서 여러번의 합병이 발생)
         * 합병이 한 번 발생할 때마다 임시배열에 원소를 정렬하는 과정에서 원소 개수만큼의 비교연산이 수행
         * 또한 원래 배열로 이동시키는 과정에서도 원소 개수만큼의 이동연산이 수행, 따라서 각 단계에서 2N만큼의 이동,비교 연산 발생
         * 그러므로 시간복잡도는 합병 단계 k번*각각의 단계에서 연산횟수 2N = O(kN), N = 2^k, k = logN이므로
         * 시간복잡도는 O(kN) = O(NlogN) 이 됨} -- 따라 쓰기는 했는데 뭔소리인지 잘 모르겠음
         * 
         * 공간을 많이 필요로함, 정렬을 하기 위해서는 데이터 전체 크기만한 메모리가 필요
         * 
         * 힙 정렬과 달리 우선순위큐를 사용하지 않음
         * 
         * 데이터를 순차적 방식으로 접근
         * 
         * 동일한 값의 우선순위는 처음 정렬과 동일하게 유지되는 안정 정렬임
         *  
         * 정렬 과정에서 별도의 추가적인 메모리(임시 배열)을 사용하므로 제자리 정렬이 아님
         * 연결리스트로 구성하면 링크 인덱스만 변경되므로 데이터의 이동은 무시할 수 있을 정도로 작아져
         * 제자리 정렬로 구현이 가능함
         * 
         * 시간복잡도는 O(n*logn)
         * 
         * 
         * 
         * <퀵정렬(Quick Sort)>
         * 처음 하나의 축(Pivot)을 정하여 이 축을 기죽으로 작은 값은 좌측, 큰 값은 우측에 위치시킨 뒤
         * 좌측과 우측의 값들을 다시 각각의 축으로 나누는걸 반복하여 축 값이 1이 될 때까지 정렬하는,
         * 더 이상 분할이 불가능할 때 까지 동작하는 알고리즘
         * 
         * 연속적인 분할에 의한 정렬방식, 재귀적으로 정렬(순환 호출)시킨다고 할 수 있음
         * 
         * 불필요한 데이터의 이동을 줄이고 먼 거리의 데이터를 교환할 뿐만 아니라
         * 한 번 결정된 축들이 추후 연산에서 제외되는 특성이 있음
         * 
         * 배열 분할 작업은 연속된 스왑 연산을 통해 수행
         * 
         * O(n*logn)의 시간복잡도를 가지는 다른 정렬 알고리즘들과 비교하였을 때도 평균적으로 속도가 매우 빠름
         * 
         * 하나의 분할 과정에서 축이 중간값 혹은 중간값에 가까운 값이 되리라는 보장이 없기에
         * 축이 최악으로 선정될 경우(랜덤으로 축을 정해도 되지만 효율성을 위해 첫번째 인덱스의 값을 축으로 선정)(가장 크거나 작은 쪽으로 치우칠 경우)
         * 시간복잡도가 O(n^2)가 될 수 있음
         * 
         * 불균형 분할을 방지하기 위해 축을 중간값으로 선택하면 효율적으로 동작할 수 있음
         * 
         * 만약 분할이 항상 가운데에서 이루어진다고 가정하면 최적의 효율을 보여줌
         * 
         * 위의 상황 때문에 안정성이 떨어지며 불균등하게 분할될 수 있음
         * 
         * 기존 배열 이외에 추가적인 메모리를 거의 사용하지 않는 제자리 정렬임
         * 
         * 평균적인 시간복잡도는 O(n*logn)
         */
        static void Main(string[] args)
        {
            Console.WriteLine("Hello, World!");
        }
    }
}
